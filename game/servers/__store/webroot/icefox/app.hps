'use strict';

load_translation('tr/${lang}.json');

register('icefox', {
  legend   : tr('Get a web page\'s content'),
  arguments: [
    {
      _       : 'url',
      legend  : tr('File\'s URL'),
      required: true
    },
    {
      long    : 'IP',
      legend  : tr('Server\'s IP if you want to connect to a server. Then, remove the prefix ${grey:xxx://}'),
      regex   : RegexCollection.IP,
      error   : tr('Bad IP adress was specified')
    },
    {
      short   : 'p',
      long    : 'port',
      legend  : tr('Port to use. If omitted, use the port 80.'),
      regex   : RegexCollection.port
    },
    {
      short   : 'd',
      long    : 'download',
      legend  : tr('Download location. If omitted, will just display the file.')
    },
    {
      short   : 't',
      long    : 'allow-styles',
      legend  : tr('Allow styles to be displayed')
    },
    {
      short   : 's',
      long    : 'allow-scripts',
      legend  : tr('Allow web page to run scripts on your server')
    }
  ],
  async    : true,
  callback : function(url, IP, port, dw, allowStyles, allowScripts, resolve) {
    if(IP) {
      // connect to a specific server
      if(!servers.hasOwnProperty(IP) || !servers[IP].network('hypernet'))
        return display_error(tr('This server doesn\'t exist or isn\'t connected to hypernet'));
    } else {
      // use Hypernet DNS
      // here, we have to set the IP adress
      var parsed = networks.hypernet.parseUrl(url);

      if(!parsed)
        return resolve('${red:' + tr('Specified URL is not valid') + '}');

      IP  = parsed.IP ;
      url = parsed.url;
    }

    var content = '', eq, barSize = 50, finalUrl = url.split(/\//)[url.split(/\//).length - 1];
    if(dw && typeof dw !== 'string') dw = finalUrl;
    
    if(dw && !needsWrite(dw))
      return resolve();

    term.set_prompt('[' + ' '.repeat(barSize) + '] 0%');

    server.download({
      url     : url ,
      IP      : IP  ,
      port    : port,
      progress: function(progress) {
        term.set_prompt('[' + '='.repeat(eq = Math.floor(progress * barSize)) + ' '.repeat(barSize - eq) + '] ' + Math.floor(progress * 100) + '%');
      },
      error   : function(err) {
        resolve('${red:' + err.split('\n').join('}\n${red:') + '}');
      },
      success : function(content) {
        if(dw) {
          if(!server.writeFile(typeof dw === 'string' ? dw : finalUrl, content))
            resolve('${red:' + tr('Unable to write the download\'s location') + '}');
          else
            resolve(tr('Download has finished successfully'));
        } else {
          var dontResolve = false;

          content = content.replace(/<%\\((.|\n)*?)%>/g, function(match, script) {
            if(!allowScripts)
              return '<%%>';

            var out = [];
            (new Function(['echo', 'forceStyles', 'dontResolve', 'resolve'], script))(
              function(text) { out.push(text); },
              function() { allowStyles = true; },
              function() { dontResolve = true; }
            , resolve);
            return out.join('\n');
          });

          updatePrompt();

          if(!dontResolve)
            resolve((allowStyles ? content : fescape(content)).replace(/<%%>/g, '${yellow:=== script removed ===}'));
        }
      }
    });
  }
});
