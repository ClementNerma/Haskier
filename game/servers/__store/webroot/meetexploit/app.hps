'use strict';

load_translation('tr/${lang}.json');

var ROOT_DIR, MASTER_SERVER = ipalias.slow9, exploit, _server = server;

save.data.me_agent = save.data.me_agent || [];
whenLogged(function(user) {

  ROOT_DIR = '/users/' + user + '/.appdata/meet.exploits';

  if(!tokenRead(ROOT_DIR) || !tokenWrite(ROOT_DIR))
    ROOT_DIR = false;

  if(!_server.dirExists(ROOT_DIR))
    _server.mkdir(ROOT_DIR);
});

var ss = {}, last;

var scope = {
  requires: function() {
    for(var i = 0; i < arguments.length; i++)
      if(typeof scope.vars[arguments[i]] === 'undefined')
        return scope.error(tr('Variable ${var} is required for exploit ${name}', [arguments[i], scope.EXPLOIT]));

    exploit.step();
  },

  internal_hack: function(checkVulnerable) {
    display('Checking internal data...');

    $setTimeout(function() {
      if(!scope.ss[serverName])
        scope.ss[serverName] = servers[serverName].secure(null, true) || {ouside: [], inside: []};

      if(checkVulnerable && scope.ss[serverName].inside.indexOf(scope.EXPLOIT) === -1)
        scope.error('This server is not vulnerable to this exploit or this exploit was already used on this server');
      else {
        if(checkVulnerable)
          scope.ss[serverName].inside.splice(scope.ss[serverName].outside.indexOf(scope.EXPLOIT), 1);

        exploit.step();
      }
    }, 1000);
  },

  load_ssh: function(checkVulnerable) {
    if(!scope.vars.IP)
      return scope.error(tr('Variable ${var} is required for exploit ${name}', ['IP', scope.EXPLOIT]));

    display('Looking for the server...');

    $setTimeout(function() {
      if(!servers.hasOwnProperty(scope.vars.IP))
        scope.error('Requested server doesn\'t exist !');
      else {
        display(tr('Trying to connect...'));

        $setTimeout(function() {
          var s = servers[scope.vars.IP];

          if(!s.network('hypernet'))
            scope.error('Requested server is not connected to hypernet');
          else if(!s.allowSSH())
            scope.error('Requested server does not support SSH');
          else {
            if(!scope.ss[scope.vars.IP])
              scope.ss[scope.vars.IP] = s.secure(null, true) || {outside: [], inside: []};

            if(checkVulnerable && scope.ss[scope.vars.IP].outside.indexOf(scope.EXPLOIT) === -1)
              scope.error('This server is not vulnerable to this exploit or this exploit was already used on this server');
            else {
              if(checkVulnerable)
                scope.ss[scope.vars.IP].outside.splice(scope.ss[scope.vars.IP].outside.indexOf(scope.EXPLOIT), 1);

              exploit.step();
            }
          }
        }, 2000);
      }
    }, 3000);
  },

  debug: function() {
    console.debug.apply(console, arguments);
    exploit.step();
  },

  display: function(text, timeout) {
    display(tr(text));
    $setTimeout(function() {
      exploit.step();
    }, timeout * (!fastdev));
  },

  error  : function(text, code) {
    display_error(tr(text));
    scope.exit(code || -1);
  },

  exit   : function(code) {
    //exploit.goLine(0);
    exploit.stop();
    last = {exploit: exploit, vars: clone(scope.vars)};

    if(code)
      display_error(tr('Exploit exited with code ${code}', [code]));
    else
      display(tr('Exploit exited with code ${code}', [0]));

    ignoreKeys = false;
    updatePrompt();
  },

  vars  : {}, // Exploit (local) variables
  ss    : {}, // Server Securities
  global: {}  // Global variables
};

scope.scope = scope; // circular reference
var metacl;

// 'metacl' is just a command alias for meta-*
register('metacl', metacl = {
  legend   : tr('Perform attacks on a system to test its security and find issues'),
  async    : true,
  arguments: [],
  callback : function(resolve) {
    if(!save.data.me_ip) {
      _server = server;

      if(!ROOT_DIR)
        return resolve('${red:' + tr('MeetExploit requires an access to appdata directory') + '}');
    } else {
      var u; for(var v = serverLogged.length - 1; v >= 0; v--) { if(serverLogged[v][0] === ipalias.local) { u = serverLogged[v][1]; break; } }

      _server = servers[save.data.me_ip];
      ROOT_DIR = '/users/' + (u || 'Shaun') + '/.appdata/meet.exploits';
    }

    if(!_server.fileExists(ROOT_DIR + '/license'))
      return resolve('${red:' + tr('No licenses file have been found. Please purchase one at ${url}', ['slow9.com/products/meetexploit/purchase']) + '}');

    if(_server.readFile(ROOT_DIR + '/license') !== servers[MASTER_SERVER].readFile('/webroot/private/license'))
      return resolve('${red:' + tr('A licenses file was found but it contains invalid data. Please re-download it from Slow9\'s website.') + '}');

    if(!save.data.me_ip)
      save.data.me_ip = serverName;

    ignoreKeys = false  ;
    exploit    = null   ;

    prompt_prefix = '${b_yellow,f_black: META } ';
    updatePrompt();

    function logo() {
      display('    __  ___             __     ______              __        _  __ ');
      display('   /  |/  /___   ___   / /_   / ____/_  __ ____   / /____   (_)/ /_');
      display('  / /|_/ // _ \\ / _ \\ / __/  / __/  | |/_// __ \\ / // __ \\ / // __/');
      display(' / /  / //  __//  __// /_   / /___ _>  < / /_/ // // /_/ // // /_  ');
      display('/_/  /_/ \\___/ \\___/ \\__/  /_____//_/|_|/ .___//_/ \\____//_/ \\__/  ');
      display('                                       /_/                         ');
      display(' ');
    }

    logo();
    display(tr('Welcome to MeetExploit interpreter'));
    display(tr('Please input your commandes here'));
    display(tr('To exit, just type ${bold:exit}'));

    catchCommand = function(cmd) {
      var match;

      if(match = cmd.match(/^use +([a-zA-Z0-9_\.\/\-]+)$/)) {
        // Use an exploit
        // If it doesn't exist

        file = ROOT_DIR + '/' + match[1] + '.exploit';

        if(!_server.fileExists(file))
          display_error(tr('Exploit "${name}" was not found', [match[1]]));
        else {
          var content = _server.readFile(file), received;

          if(content.split('\n')[0] !== (received = servers[MASTER_SERVER].readFile('/webroot/private/exploits/' + match[1] + '.exploit')).split('\n')[0])
            display_error(tr('Exploit is not valid : "${name}"', [match[1]]));
          else {
            scope.vars = clone(scope.global);
            scope.EXPLOIT = match[1];
            var hasHelp = !!received.split('\n').slice(1)[0].match(/^HELP *=>/);
            received = received.split('\n').slice(1 + hasHelp).join('\n');
            exploit  = scope.exploit = HSF.parse(received, scope, {});
            exploit.event('error', function(line, code, stack) {
              console.error('JS parsing has failed. Line: ' + code + '\nDetails :\n' + stack);
              scope.error('Exploit has crashed.', -1);
            });
          }
        }
      } else if(match = cmd.match(/^set +global:([a-zA-Z]+) +([a-zA-Z0-9_\.\/\- ]+)$/)) {
        // Set an global variable
        scope.global[match[1] = match[1].toLocaleUpperCase()] = match[2];
        display(fescape(match[1] + ' [GLOBAL] => ' + match[2]));
      } else if(match = cmd.match(/^set +([a-zA-Z]+) +([a-zA-Z0-9_\.\/\- ]+)$/)) {
        // Set an exploit variable
        // If no exploit have been set, make a global variable
        scope[exploit ? 'vars' : 'global'][match[1] = match[1].toLocaleUpperCase()] = match[2];
        display(fescape(match[1] + (exploit ? ' ' : ' [GLOBAL]') + ' => ' + match[2]));

        if(!exploit)
          display('${italic:' + tr('Automatically set to global variable') + '}');
      } else if(match = cmd.match(/^get +(global:|)([a-zA-Z]+)$/)) {
        // Get a variable
        var disp = scope[match[1] ? 'global' : 'vars'];

        if(!disp.hasOwnProperty(match[2] = match[2].toLocaleUpperCase()))
          display('${italic:' + tr('Variable not found') + '}');
        else
          display(fescape(match[2] + (match[1] ? ' [GLOBAL]' : ' ') + ' => ' + disp[match[2]]));
      } else if(match = cmd.match(/^del +(global:|)([a-zA-Z]+)$/)) {
        // Erase a variables
        var disp = scope[match[1] ? 'global' : 'vars'];

        if(!disp.hasOwnProperty(match[2] = match[2].toLocaleUpperCase()))
          display_error(tr('Variable not found'));
        else {
          delete disp[match[2]];
          display(tr('${italic:Variable has been removed}'));
        }
      } else if(cmd === 'exploit') {
        // Do the exploit !
        if(!exploit)
          display_error(tr('No exploit have been prepared !'));
        else {
          ignoreKeys = true;
          dontRecoverPrompt = true;
          term.set_prompt('');
          exploit.goLine(0);
          exploit.run();
        }
      } else if(cmd === 'exit') {
        display(tr('Goodbye !'));
        catchCommand  = null;
        prompt_prefix = '';
        resolve();
        return ;
      } else if(cmd === 'clear')
        term.clear();
      else if(cmd === 'logo')
        logo();
      else if(match = cmd.match(/^help +([a-zA-Z0-9_\-\/]+)$/)) {
        // Get help on an exploit
        var file = _server.normalize('/' + match[1] + '.exploit', true);
        file = ROOT_DIR + file;

        if(!_server.fileExists(file))
          display_error(tr('Exploit "${name}" was not found', [match[1]]));
        else {
          var content = _server.readFile(file), received;

          if(content.split('\n')[0] !== (received = servers[MASTER_SERVER].readFile('/webroot/private/exploits/' + match[1] + '.exploit')).split('\n')[0])
            display_error(tr('Exploit is not valid : "${name}"', [match[1]]));
          else {
            var line0 = received.split('\n').slice(1)[0];

            if(!line0.match(/^HELP *=>/))
              display_error('No help was found for this exploit');
            else {
              // Display help
              line0 = line0.replace(/^HELP *=> */, '').split(',');

              for(var i = 0, l, g; i < line0.length; i++) {
                l = line0[i].trim(); g = l.indexOf(' ');
                display(l.substr(0, g) + ' : ' + l.substr(g + 1));
              }
            }
          }
        }
      } else if(cmd)
        display_error(tr('Command not found "${cmd}"', [cmd.split(' ')[0]]));

      return RESTORE_COMMAND_CALLBACK;
    };
  }
});

// Register SSH agent
if(!window.$ME_runned) {
  ssh_event('log', function(ip, user) {
    if(save.data.me_agent.indexOf(ip) !== -1)
      commands.metacl = metacl;
  });

  window.$ME_runned = true;
}

// Export some features...
exports('get_exploit', function(exploit) {
  return servers[MASTER_SERVER].readFile('/webroot/private/exploits/' + exploit + '.exploit');
});

exports('get_referer', function(exploit) {
  var file = servers[MASTER_SERVER].readFile('/webroot/private/exploits/' + exploit + '.exploit');
  return file ? file.split('\n')[0] : false;
});

exports('install_exploit', function(exploit) {
  if(!ROOT_DIR)
    return false;

  var file = servers[MASTER_SERVER].readFile('/webroot/private/exploits/' + exploit + '.exploit');
  if(!file) return false;

  return _server.writeFile(ROOT_DIR + '/' + exploit + '.exploit', file.split('\n')[0]);
});

exports('install_license', function() {
  var r = servers[MASTER_SERVER].readFile('/webroot/private/license');
  if(!r) return false;
  return _server.writeFile(ROOT_DIR + '/license', r);
});
